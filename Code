#include <algorithm>
#include <cmath>
#include <iostream>


struct Vec {
  float x;
  float y;
};

struct Vec2 {
  float x;
  float y;
};

struct Circle {
  float radius;
  Vec position;
};

struct AABB {
  Vec2 min;
  Vec2 max;
};


struct Object {
  Vec2 velocity;
  float restitution;
  float mass;
  
  // Add other necessary members as needed
};

bool AABBvsAABB(AABB a, AABB b) {
  // Exit with no intersection if found separated along an axis
  if (a.max.x < b.min.x or a.min.x > b.max.x)
    return false;
  if (a.max.y < b.min.y or a.min.y > b.max.y)
    return false;
  // No separating axis found, therefor there is at least one overlapping axis
  return true;
};

// class Distance {
// public:
//   Distance(Vec2 a, Vec2 b) { // Constructor
//     this->a = a;
//     this->b = b;
//   }

//   float calculateDistance() { // Method to calculate distance
//     return sqrt(pow(a.x - b.x, 2) + pow(a.y - b.y, 2));
//   }
// private:
//   Vec2 a;
//   Vec2 b;
//};

float Distance(Vec2 a, Vec2 b) {
  return sqrt(pow(a.x - b.x, 2) + pow(a.y - b.y, 2));
}

bool CirclevsCircleUnoptimized(Circle a, Circle b) {
  float r = a.radius + b.radius;
  Vec2 aPos = {a.position.x, a.position.y}; // Create Vec2 from Vec
  Vec2 bPos = {b.position.x, b.position.y}; // Create Vec2 from Vec
  return r < Distance(aPos, bPos);
}

bool CirclevsCircleOptimized(Circle a, Circle b) {
  float r = a.radius + b.radius;
  r *= r;
  return r < (a.position.x - b.position.x) * (a.position.x - b.position.x) +
                 (a.position.y - b.position.y) * (a.position.y - b.position.y);
}


// Object X {{velocity}, restitution, mass}

Object A = {{10, 0}, 0.8f, 1.0f};
Object B = {{10, 0}, 0.8f, 1.0f};

// Given two objects A and B 
float e = std::min( A.restitution, B.restitution );



void ResolveCollision( Object A, Object B )
{
  // Calculate relative velocity 
  Vec2 rv = B.velocity - A.velocity;
  // Calculate relative velocity in terms of the normal direction 
  float velAlongNormal = DotProduct( rv, normal );
  // Do not resolve if velocities are separating 
  if(velAlongNormal > 0)
    return;
  // Calculate restitution 
  float e = std::min( A.restitution, B.restitution);
  // Calculate impulse scalar 
  float j = -(1 + e) * velAlongNormal
  j /= 1 / A.mass + 1 / B.mass
  // Apply impulse 
  Vec2 impulse = j * normal
  A.velocity -= 1 / A.mass * impulse
  B.velocity += 1 / B.mass * impulse
}





// int main() {

//   Circle one = {5, {60, 50}};

//   return 0;
// }

