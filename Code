#include <algorithm>
#include <cmath>
#include <iostream>


struct Vec {
  float x;
  float y;
};

struct Vec2 {
  float x;
  float y;
};

struct Circle {
  float radius;
  Vec position;
};

struct AABB {
  Vec2 min;
  Vec2 max;
};


struct Object {
  Vec2 velocity;
  float restitution;
  float mass;
  float inv_mass;
  // Add other necessary members as needed
};

bool AABBvsAABB(AABB a, AABB b) {
  // Exit with no intersection if found separated along an axis
  if (a.max.x < b.min.x or a.min.x > b.max.x)
    return false;
  if (a.max.y < b.min.y or a.min.y > b.max.y)
    return false;
  // No separating axis found, therefor there is at least one overlapping axis
  return true;
};

// class Distance {
// public:
//   Distance(Vec2 a, Vec2 b) { // Constructor
//     this->a = a;
//     this->b = b;
//   }

//   float calculateDistance() { // Method to calculate distance
//     return sqrt(pow(a.x - b.x, 2) + pow(a.y - b.y, 2));
//   }
// private:
//   Vec2 a;
//   Vec2 b;
//};

float Distance(Vec2 a, Vec2 b) {
  return sqrt(pow(a.x - b.x, 2) + pow(a.y - b.y, 2));
}

bool CirclevsCircleUnoptimized(Circle a, Circle b) {
  float r = a.radius + b.radius;
  Vec2 aPos = {a.position.x, a.position.y}; // Create Vec2 from Vec
  Vec2 bPos = {b.position.x, b.position.y}; // Create Vec2 from Vec
  return r < Distance(aPos, bPos);
}

bool CirclevsCircleOptimized(Circle a, Circle b) {
  float r = a.radius + b.radius;
  r *= r;
  return r < (a.position.x - b.position.x) * (a.position.x - b.position.x) +
                 (a.position.y - b.position.y) * (a.position.y - b.position.y);
}


// Object X {{velocity}, restitution, mass, inv_mass= 1/mass}

Object A = {{10, 0}, 0.8f, 2.0f, 1.0f / 2.0f}; 

Object B = {{10, 0}, 0.8f, 2.0f, 1.0f / 2.0f}; 








// Given two objects A and B 
float e = std::min( A.restitution, B.restitution );


float DotProduct(Vec2 a, Vec2 b) {
  return a.x * b.x + a.y * b.y; 
}


void ResolveCollision( Object A, Object B, Vec2 normal )
{
  // Calculate relative velocity 
  Vec2 rv = {B.velocity.x - A.velocity.x, B.velocity.y - A.velocity.y};
  // Calculate relative velocity in terms of the normal direction 
  float velAlongNormal = DotProduct( rv, normal );
  // Do not resolve if velocities are separating 
  if(velAlongNormal > 0)
    return;
  // Calculate restitution 
  float e = std::min( A.restitution, B.restitution);
  // Calculate impulse scalar 
  float j = -(1 + e) * velAlongNormal;
  j /= 1 / A.mass + 1 / B.mass;
  // Apply impulse 
  Vec2 impulse = {j * normal.x, j * normal.y};
  A.velocity.x -= 1 / A.mass * impulse.x;
  A.velocity.y -= 1 / A.mass * impulse.y;
  B.velocity.x += 1 / B.mass * impulse.x;
  B.velocity.y += 1 / B.mass * impulse.y;



  float mass_sum = A.mass + B.mass;
  float ratio = A.mass / mass_sum;
  A.velocity.x -= ratio * impulse.x;
  A.velocity.y -= ratio * impulse.y;
  ratio = B.mass / mass_sum;
  B.velocity.x += ratio * impulse.x;
  B.velocity.y += ratio * impulse.y;

}



// int main() {

//   Circle one = {5, {60, 50}};

//   return 0;
// }
